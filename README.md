Credits: Mostly created by Aprillomat

# What this is
We organised a Hollow Knight Tourney livestreamed on the HollowKnightCommunity twitch channel and created UI for Viewers, Restreamer and Runner. The Category ran was SBRCO, which is Salubra's Blessing Random Charm Order, or in other words, the Runner has to collect all Charms in a given Random Order.

# UI
### Generation of Charm Order
When running charm_select.py, this UI appears:
![screenshot](https://i.imgur.com/NuBb43O.png)
The user can change the logic parameters defined by Resources/config/logic.txt to their liking and generate a random charm order (created by generate_charmlist.py). Afterwards they can click on Generate lss which generates an Autosplitter file. The List is encoded in a b64 string which can be used to generate the charmList by clicking on the Radiobutton and then Generate Charm Order.
### Runner
When running runner.py, this UI appear:
![screenshot](https://i.imgur.com/lA9qs7t.png)
If Connected to a server (just run server.py), this will display the charm order (generated by Restreamer.py, explained afterwards) and the current Charm the user is on (this is read (in client.py) by either connecting to a livesplit server, or in the case of the current state by a file called "charms.txt" in Appdata/Local/Temp, created by a modified Game Version which writes all obtained charms, equipped charms, and grubs to a text file). The index of the current Charm you're on is equivalent to the amount of Charms obtained.
### Restreamer
When running Restreamer.py, these UI's appear:
![screenshot](https://i.imgur.com/exqhEdt.png)
![screenshot](https://i.imgur.com/kh2NL8I.png)
(The UI is created by widget.py)
If you connect to the just mentioned server in restream control, it'll read the number of charms obtained by each Player (using 5 bytes since it's a bitmask for each charm, the order is the same as the Game's Order) and the charms equipped. Note that Restreamer.py also opens generate_charmlist.py and automatically inserts the generated charmlist into its UI as well as sending the b64 string to the server which in turn sends it to runner.py



